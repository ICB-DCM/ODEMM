function varargout = generateODEMM(D,M,parameters,conditions,varargin)
% This function generates file defining ODE-constrained mixture model
%
% USAGE:
% M = generateODEMM(D,M,parameters,conditions,options)
%
% Parameters:
% M: model struct
% D: data struct 
% parameters: parameters struct
% conditions: conditions struct obtained by collectConditions.m
% varargin: 
% options: 

% Required fields of D:
%
%
% conditions ... obtained by collectConditions.m
%
% Optional fields of options:
%       write_parameter: write parameter definition in file, @default
%                               true
%       measurement_noise:
%                = true
%                = false (default)
%       replicates: 
%               = true 
%               = @default false 
%       sigmas:
%         = ''condition-dependent'':  @default assign sigma for every time point
%         = ''time-independent'':  sigma stays the same for subpopulation
%                       and some dose
%         = ''only-one'': only one sigma for everything
%
% Required fields of M:
%  name: name of the model
%  model: simulation file with input (T,theta,u) (e.g. generated by
%            amiwrap), the first output needs to be the status of the
%            simulation (whether it failed or not) the 4th the simulation
%            output, and the 6th the sensitivities
%  sim_type: simulation type
%       = 'RRE' ... reaction rate equation model
%       = 'HO' ... higher order moments (e.g. Moment approximation or Sigma
%       Points)
%       = 'MCM' ... method of conditional moments
%  n_subpop: number of subpopulations
%  distribution{s,e}: distribution assumption
%       = ''norm': normal distribution assumption
%       = ''logn_median'': lognormal distribution assumption, mean of
%                        simulation linked to median of distribution
%       = ''logn_mean'': lognormal distribution assumption, mean of
%                        simulation linked to mean of distribution
%  mean_ind{s,e}: indices of simulation output describing the mean of
%               the measurand(s) of experiment e
%  var_ind{s,e}:  indices of simulation output describing the variance (empty
%               if RREs used)
%  u{s,e}: input vector describing differences between subpopulations
%               and experiments
%  sym: symbolic description of properties of the model
%      .w{s,e}: weights of subpopulation s in experiment e (empty if
%                     MCM is used)
%      .theta: parameter needed for simulation of individual
%                   subpopulations
%      .scaling{r,e}: scaling factor for replicate r in experiment e, if the
%                     replicates are not considered seperately, use r=1
%      .offset{r,e}: offset parameter for replicate r in experiment e

options.write_parameters = true;
options.measurement_noise = false;
options.replicates = false;
options.path = [];
if nargin == 5
    options = setdefault(varargin{1},options);
end

%% check M fields
if ~isfield(M,'mean_ind')
    error('For M the field mean_ind needs to be defined!');
end
switch M.sim_type
    case 'RRE'
        for s = 1:M.n_subpop
            for e = 1:length(D)
                M.w_ind{s,e} = [];
                M.var_ind{s,e} = [];
            end
        end
    case 'HO'
        if ~isfield(M,'var_ind')
            error('For M the field var_ind needs to be defined!');
        end
        for s = 1:M.n_subpop
            for e = 1:length(D)
                M.w_ind{s,e} = [];
            end
        end
    case 'MCM'
        if ~isfield(M,'w_ind')
            error('For M the field w_ind needs to be defined!');
        end
        if ~isfield(M,'var_ind')
            error('For M the field var_ind needs to be defined!');
        end
    otherwise
        error('M.sim_type needs to be ''HO'', ''RRE'' or ''MCM''!');
end


disp(['Start generation of ODEMM for ' M.name '...']);
dimension_all = 0;
for e = 1:length(D)
    for s = 1:M.n_subpop
        num_w = 0;
        if strcmp(M.sim_type,'MCM')
            num_w = M.n_subpop-1;
        end
        if length(M.mean_ind{s,e})+length(M.var_ind{s,e})+num_w > dimension_all
            dimension_all = length(M.mean_ind{s,e})+...
                length(M.var_ind{s,e})+num_w;
        end
    end
end
xi = sym(zeros(parameters.number,1));
for i = 1:parameters.number
    xi(i) = sym(['xi_' num2str(i,'%d')]);
end
x =  sym(zeros(dimension_all,1));
dxdxi = sym(zeros(dimension_all,1));
sigma = sym('sigma');
dsigmadxi = sym('dsigmadxi');
for i = 1:dimension_all
    x(i) = sym(['x_' num2str(i,'%d')]);
    dxdxi(i) = sym(['dxdxi_' num2str(i,'%d')]);
end

%% theta
str_theta = ['M.theta = @(xi,u) '];
str_theta = strcat(str_theta,strcat(replace_xi_x_u(M.sym.theta),';'));
%% dthetadxi
M.sym.dthetadxi = jacobian(M.sym.theta, xi);
str_dthetadxi = ['M.dthetadxi= @(xi,u) '];
str_dthetadxi = strcat(str_dthetadxi,strcat(replace_xi_x_u(M.sym.dthetadxi),';'));

for e = 1:length(D)
    for s = 1:M.n_subpop
        %% initialize sigma
        switch M.sim_type
            case 'RRE'
                switch options.sigmas
                    case 'subpopulation-specific'
                        if D(e).n_dim == 1
                            M.sym.sigma{s,e} = 10.^xi(ones(1,numel(D(e).t))*D(e).sigma{s});
                        else
                            M.sym.ind{s,e} = sym(D(e).Sigma{s});
                        end
                    case 'time-dependent'
                        if D(e).n_dim == 1
                            M.sym.sigma{s,e} = 10.^xi(D(e).sigma{s});
                        else
                            M.sym.ind{s,e} = sym(D(e).Sigma{s});
                        end
                    case 'condition-dependent'
                        if D(e).n_dim == 1
                            M.sym.sigma{s,e} = 10.^xi(conditions(D(e).c(s,1)).sigma);
                        else
                            M.sym.ind{s,e} = sym(conditions(D(e).c(s,1)).Sigma);
                        end
                    case {'time-independent','only-one'}
                        M.sym.sigma{s,e} = 10.^xi(ones(1,numel(D(e).t))*conditions(D(e).c(s,1)).sigma);
                end
            case {'HO','MCM'}
                % M.sym.sigma{s,e} = x(2);
                switch M.distribution{s,e}
                    case 'norm'
                        if options.measurement_noise
                            M.sym.sigma{s,e} = sqrt(x(2)+M.sym.sigma_noise{e}.^2);
                        else
                            M.sym.sigma{s,e} = sqrt(x(2));
                        end
                    case 'logn_median'
                        if options.measurement_noise
                            switch options.noise_model
                                case 'multiplicative'
                                    M.sym.sigma{s,e} = sqrt(log(x(2)/(x(1)^2)+1)+M.sym.sigma_noise{e}.^2);
                                case 'additive'
                                    M.sym.sigma{s,e} = sqrt(log((x(2)+M.sym.sigma_noise{e}.^2)/(x(1)^2)+1));
                            end
                        else
                            M.sym.sigma{s,e} = sqrt(log(x(2)/(x(1)^2)+1));
                        end
                    case 'logn_mean'
                        if options.measurement_noise
                            M.sym.sigma{s,e} = sqrt(log(x(2)/(x(1)^2)+1)+M.sym.sigma_noise{e}.^2);
                        else
                            M.sym.sigma{s,e} = sqrt(log(x(2)/(x(1)^2)+1));
                        end
                end
        end
        %% initialize mu/other parameters
        switch M.distribution{s,e}
            case 'norm'
                M.sym.mu{s,e} = x(1);
            case 'logn_median'
                M.sym.mu{s,e} = log(x(1));
            case 'logn_mean'
                M.sym.mu{s,e} = log(x(1))-(sigma.^2)/2;
        end
    end
end

%% CONSTRUCT SIMULATION FILE
clear([options.path 'ODEMM_' M.name '.m']);
% Open file
fid = fopen([options.path 'ODEMM_' M.name '.m'],'w');
% Construct string
fprintf(fid,['%%%% Definition of model\n']);
fprintf(fid,['M.name = ''' M.name '''; \n']);
fprintf(fid,['M.n_subpop = ' num2str(M.n_subpop) '; \n']);
fprintf(fid,['M.model = ' char(M.model) '; \n']);
fprintf(fid,[str_theta '\n']);
fprintf(fid,[str_dthetadxi '\n\n']);

%% generate strings
for s = 1:M.n_subpop
    for e = 1:length(D)
        disp(['...generate definition of subpopulation ' num2str(s) ' in experiment ' num2str(e) '...']);
        switch M.sim_type
            case {'RRE','HO'}
                %% w
                str_w =['M.w{s,e} = @(t,x,xi,u) '];
                str_w = strcat(str_w,strcat(replace_xi_x_u(M.sym.w{s,e}),';'));
                %% dwdxi
                str_dwdxi = strcat(['M.dwdxi{s,e} = @(t,x,dxdxi,xi,u)'], getStrDerivative2Terms(M.sym.w{s,e}, x, dxdxi, xi));
                str_dwdxi = [str_dwdxi, ';'];
                str_dwdxi = regexprep(str_dwdxi,'u_([0-9]+)','u($1)');
            case 'MCM'
                if s < M.n_subpop
                    ind_w = length(M.mean_ind{s,e}) + length(M.var_ind{s,e}) +1;
                    str_w = ['M.w{s,e} = @(t,x,xi,u) x(:,' num2str(ind_w) ');'];
                    str_dwdxi = ['M.dwdxi{s,e} = @(t,x,dxdxi,xi,u) permute(dxdxi(' num2str(ind_w) ',:,:),[3,2,1]);'];
                else
                    ind_w = length(M.mean_ind{s,e}) + length(M.var_ind{s,e}) +1;
                    str_w = 'M.w{s,e} = @(t,x,xi,u) 1';
                    str_dwdxi = 'M.dwdxi{s,e} = @(t,x,dxdxi,xi,u)' ;
                    for z = 1:M.n_subpop-1
                        str_w = strcat(str_w,['-x(:,' num2str(ind_w) ')']);
                        if M.n_subpop > 2
                            error('TODO')
                        else
                            str_dwdxi = strcat(str_dwdxi,['-permute(dxdxi('  num2str(ind_w) ',:,:),[3,2,1])']);
                        end
                        ind_w = ind_w+1;
                    end
                    str_w = strcat(str_w,';');
                    str_dwdxi = strcat(str_dwdxi,';');
                end
        end
        
        if D(e).n_dim == 1
            %% mu
            str_mu =['M.mu{s,e} = @(t,x,sigma,xi,u) ['];
            str_temp = regexprep(char(M.sym.mu{s,e}),'xi_([0-9]+)','xi($1)');
            str_temp = regexprep(str_temp,'\^','.^');
            str_mu = strcat(str_mu,regexprep(str_temp,'x_([0-9]+)','x(:,$1)'));
            str_mu = [str_mu '];'];
            %% dmudxi
            str_dmudxi = getStrDerivative3Terms('dmudxi',M.sym.mu,s,e,x,dxdxi,sigma,dsigmadxi,xi);
        else
            %% mu
            str_mu =['M.mu{s,e} = @(t,x,Sigma,xi,u) ['];
            switch M.distribution{s,e}
                case 'logn_mean'
                    for n = 1:D(e).n_dim
                        str_mu = [str_mu 'log(x(:,' num2str(n) ')) - 0.5*Sigma(:,' num2str(n) ',' num2str(n) ')'];
                        if n < D(e).n_dim
                            str_mu = [str_mu ',...\n'];
                        else
                            str_mu = [str_mu '];\n'];
                        end
                    end
                case 'logn_median'
                    for n = 1:D(e).n_dim
                        str_mu = [str_mu 'log(x(:,' num2str(n) '))'];
                        if n < D(e).n_dim
                            str_mu = [str_mu ','];
                        else
                            str_mu = [str_mu '];\n'];
                        end
                    end
                case 'norm'
                    for n = 1:D(e).n_dim
                        str_mu = [str_mu 'x(:,' num2str(n) ')'];
                        if n < D(e).n_dim
                            str_mu = [str_mu ','];
                        else
                            str_mu = [str_mu '];\n'];
                        end
                    end
            end
            %% dmudxi
            str_dmudxi = ['M.dmudxi{s,e} = @(t,x,dxdxi,Sigma,dSigmadxi,xi,u) func_dmudxi_' M.distribution{s,e}...
                '(t,x,dxdxi,Sigma,dSigmadxi,xi,u,' num2str(D(e).n_dim) ');'];
        end
        
        if options.replicates
            % consider replicates individually
            rs = 1:length(D(e).replicate);
        else
            % consider scaled and merged replicates
            rs = 1;
        end
        for r = rs
            %% s,b
            str_s{r} =  'M.scaling{r,e} = @(xi,u) ';
            str_s{r} = strcat(str_s{r},strcat(replace_xi_x_u(M.sym.scaling{r,e}),';'));
            str_b{r} =  'M.offset{r,e} = @(xi,u) ';
            str_b{r} = strcat(str_b{r},strcat(replace_xi_x_u(M.sym.offset{r,e}),';'));

            str_dsdxi{r} = 'M.dscalingdxi{r,e} = @(xi,u) ';
            str_dbdxi{r} = 'M.doffsetdxi{r,e} = @(xi,u) ';
            M.sym.dscalingdxi{r,e} = jacobian(M.sym.scaling{r,e},xi);
            M.sym.doffsetdxi{r,e} = jacobian(M.sym.offset{r,e},xi);
            str_dsdxi{r} = strcat(str_dsdxi{r},strcat(replace_xi_x_u(M.sym.dscalingdxi{r,e}),';'));
            str_dbdxi{r} = strcat(str_dbdxi{r},strcat(replace_xi_x_u(M.sym.doffsetdxi{r,e}),';'));
        end
        
        %% dsigma dsigmadxi
        if D(e).n_dim > 1
            switch M.sim_type
                case {'HO','MCM'}
                    switch M.distribution{s,e}
                        case {'logn','logn_mean','logn_median'}
                            if options.measurement_noise
                                str_noise = '[';
                                for k = 1:D(e).n_dim
                                    str_noise = strcat(str_noise,regexprep(char(M.sym.sigma_noise{e}(k).^2),'xi_([0-9]+)','xi($1)'));
                                    str_noise = regexprep(str_noise,'u_([0-9]+)','u($1)');
                                    if k < D(e).n_dim
                                        str_noise = [str_noise ';'];
                                    else
                                        str_noise = [str_noise ']'];
                                    end
                                end
                                
                                str_dnoisedxi = '[';
                                M.sym.dnoisedxi{e} = jacobian(M.sym.sigma_noise{e}.^2,xi);
                                for l = 1:D(e).n_dim
                                    for k = 1:length(M.sym.dnoisedxi{e})
                                        str_dnoisedxi = strcat(str_dnoisedxi,regexprep(char(M.sym.dnoisedxi{e}(l,k)),'xi_([0-9]+)','xi($1)'));
                                        str_dnoisedxi = regexprep(str_dnoisedxi,'u_([0-9]+)','u($1)');
                                        if k<size(M.sym.dnoisedxi{e},2)
                                            str_dnoisedxi = [str_dnoisedxi ','];
                                        elseif k==size(M.sym.dnoisedxi{e},2) && l < D(e).n_dim
                                            str_dnoisedxi = [str_dnoisedxi ';...\n'];
                                        elseif k==size(M.sym.dnoisedxi{e},2) && l == D(e).n_dim
                                            str_dnoisedxi = [str_dnoisedxi ']'];
                                        end
                                    end
                                end
                                str_sigma = ['M.Sigma{s,e} = @(t,x,xi,u) func_Sigma_logn(t,x,xi,' num2str(D(e).n_dim)...
                                    ',' str_noise ,',''' options.noise_model ''');'];
                                str_dsigmadxi = ['M.dSigmadxi{s,e} = @(t,x,dxdxi,xi,u) func_dSigmadxi_logn(t,x,dxdxi,xi,' num2str(D(e).n_dim)...
                                    ',' str_noise ',' str_dnoisedxi ',''' options.noise_model ''');'];
                            else
                                str_sigma = ['M.Sigma{s,e} = @(t,x,xi,u) func_Sigma_logn(t,x,xi,' num2str(D(e).n_dim) ');'];
                                str_dsigmadxi = ['M.dSigmadxi{s,e} = @(t,x,dxdxi,xi,u) func_dSigmadxi_logn(t,x,dxdxi,xi,' num2str(D(e).n_dim) ');'];
                            end
                        case 'norm'
                            if options.measurement_noise
                                str_noise = '[';
                                for k = 1:D(e).n_dim
                                    str_noise = strcat(str_noise,regexprep(char(M.sym.sigma_noise{e}(k).^2),'xi_([0-9]+)','xi($1)'));
                                    str_noise = regexprep(str_noise,'u_([0-9]+)','u($1)');
                                    if k < D(e).n_dim
                                        str_noise = [str_noise ';'];
                                    else
                                        str_noise = [str_noise ']'];
                                    end
                                end
                                
                                str_dnoisedxi = '[';
                                M.sym.dnoisedxi{e} = jacobian(M.sym.sigma_noise{e}.^2,xi);
                                for l = 1:D(e).n_dim
                                    for k = 1:length(M.sym.dnoisedxi{e})
                                        str_dnoisedxi = strcat(str_dnoisedxi,regexprep(char(M.sym.dnoisedxi{e}(l,k)),'xi_([0-9]+)','xi($1)'));
                                        str_dnoisedxi = regexprep(str_dnoisedxi,'u_([0-9]+)','u($1)');
                                        if k<size(M.sym.dnoisedxi{e},2)
                                            str_dnoisedxi = [str_dnoisedxi ','];
                                        elseif k==size(M.sym.dnoisedxi{e},2) && l < D(e).n_dim
                                            str_dnoisedxi = [str_dnoisedxi ';...\n'];
                                        elseif k==size(M.sym.dnoisedxi{e},2) && l == D(e).n_dim
                                            str_dnoisedxi = [str_dnoisedxi ']'];
                                        end
                                    end
                                end
                                
                                str_sigma = ['M.Sigma{s,e} = @(t,x,xi,u) func_Sigma_norm(t,x,xi,' num2str(D(e).n_dim)...
                                    ',' str_noise ',''' options.noise_model ''');'];
                                str_dsigmadxi = ['M.dSigmadxi{s,e} = @(t,x,dxdxi,xi,u) func_dSigmadxi_norm(t,x,dxdxi,xi,' num2str(D(e).n_dim)...
                                    ',' str_noise ',' str_dnoisedxi ',''' options.noise_model ''');'];
                            else
                                str_sigma = ['M.Sigma{s,e} = @(t,x,xi,u) func_Sigma_norm(t,x,xi,' num2str(D(e).n_dim) ');'];
                                str_dsigmadxi = ['M.dSigmadxi{s,e} = @(t,x,dxdxi,xi,u) func_dSigmadxi_norm(t,x,dxdxi,xi,' num2str(D(e).n_dim) ');'];
                            end
                            
                    end
                case 'RRE'
                    if size(D(e).u,2) == 1
                        ind = '[';
                        for l = 1:size(M.sym.ind{s,e},2)
                            for k = 1:size(M.sym.ind{s,e},1)
                                ind = strcat(ind,char(M.sym.ind{s,e}(k,l)));
                                ind = strcat(ind,',');
                            end
                        end
                        ind = strcat(ind,']');
                        if options.covariance
                            str_sigma = ['M.Sigma{s,e} = @(t,x,xi,u) func_Sigma_RRE_cov(t,x,xi,' num2str(D(e).n_dim) ', ' ind ' );'];
                            str_dsigmadxi = ['M.dSigmadxi{s,e} = @(t,x,dxdxi,xi,u) func_dSigmadxi_RRE_cov(t,x,dxdxi,xi,' num2str(D(e).n_dim) ', ' ind ');'];
                        else
                            str_sigma = ['M.Sigma{s,e} = @(t,x,xi,u) func_Sigma_RRE(t,x,xi,' num2str(D(e).n_dim) ', ' ind ' );'];
                            str_dsigmadxi = ['M.dSigmadxi{s,e} = @(t,x,dxdxi,xi,u) func_dSigmadxi_RRE(t,x,dxdxi,xi,' num2str(D(e).n_dim) ', ' ind ');'];
                        end
                    else
                        str_sigma = ['M.Sigma{s,e} = @(t,x,xi,u) ']
                        str_dsigmadxi = ['M.dSigmadxi{s,e} = @(t,x,dxdxi,xi,u) ' ]
                        for d = 1:size(D(e).u,2)
                            str = ['('];
                            for d_dim = 1:size(D(e).u,1)
                                str = [str '(u(' num2str(d_dim) ')==' num2str(D(e).u(d_dim,d)) ')'];
                                if d_dim < size(D(e).u,1)
                                    str = [str ' & '];
                                end
                            end
                            str = [str ')*'];
                            ind = '[';
                            if options.covariance
                                for l = 1:3
                                    ind = strcat(ind,num2str(D(e).Sigma{s}(l,d)));
                                    if l < 3
                                        ind = strcat(ind,',');
                                    end
                                end
                            else
                                for l = 1:2
                                    ind = strcat(ind,num2str(D(e).Sigma{s}(l,d)));
                                    if l < 2
                                        ind = strcat(ind,',');
                                    end
                                end
                            end
                            ind = strcat(ind,']');
                            if options.covariance
                                str_sigma = strcat(str_sigma,[str 'func_Sigma_RRE_cov(t,x,xi,' num2str(D(e).n_dim) ', ' ind ' )']);
                                str_dsigmadxi = strcat(str_dsigmadxi,[str ' func_dSigmadxi_RRE_cov(t,x,dxdxi,xi,' num2str(D(e).n_dim) ', ' ind ')']);
                            else
                                str_sigma = strcat(str_sigma,[str 'func_Sigma_RRE(t,x,xi,' num2str(D(e).n_dim) ', ' ind ' )']);
                                str_dsigmadxi = strcat(str_dsigmadxi,[str ' func_dSigmadxi_RRE(t,x,dxdxi,xi,' num2str(D(e).n_dim) ', ' ind ')']);
                                
                            end
                            if d < size(D(e).u,2)
                                str_sigma = strcat(str_sigma,'+');
                                str_dsigmadxi = strcat(str_dsigmadxi,'+');
                            end
                            
                        end
                        str_sigma = strcat(str_sigma,';');
                        str_dsigmadxi = strcat(str_dsigmadxi,';');
                    end
                    
            end
        else
            
            str_sigma = ['M.sigma{s,e} = @(t,x,xi,u)\t'];
            str_dsigmadxi = ['M.dsigmadxi{s,e} = @(t,x,dxdxi,xi,u)\t'];
            switch M.sim_type
                case {'HO','MCM'}
                    str_sigma = [str_sigma '['];
                    str_temp = regexprep(char(M.sym.sigma{s,e}),'xi_([0-9]+)','xi($1)');
                    str_temp = regexprep(str_temp,'/','./');
                    str_temp = regexprep(str_temp,'\^','.^');
                    str_temp = regexprep(str_temp,'x_([0-9]+)','x(:,$1)');
                    str_sigma = strcat(str_sigma,str_temp);
                    str_sigma = [str_sigma '];'];
                    % ACHTUNG HARD GECODED
                    %sw%tch M.distribution{s,e}
                    % case {'logn_median','logn_mean'}
                    if options.measurement_noise
                        str_noise = regexprep(char(M.sym.sigma_noise{e}.^2),'xi_([0-9]+)','xi($1)');
                        str_dnoisedxi = '[';
                        M.sym.dnoisedxi{e} = jacobian(M.sym.sigma_noise{e}.^2,xi);
                        for k = 1:length(M.sym.dnoisedxi{e})
                            str_dnoisedxi = strcat(str_dnoisedxi,regexprep(char(M.sym.dnoisedxi{e}(k)),'xi_([0-9]+)','xi($1)'));
                            str_dnoisedxi = regexprep(str_dnoisedxi,'u_([0-9]+)','u($1)');
                            if k<size(M.sym.dnoisedxi{e},2)
                                str_dnoisedxi = [str_dnoisedxi ','];
                            else
                                str_dnoisedxi = [str_dnoisedxi ']'];
                            end
                        end
                        switch M.distribution{s,e}
                            case {'logn_median','logn','logn_mean'}
                                str_dsigmadxi = [str_dsigmadxi 'bsxfun(@rdivide,func_dsigma2dxi_logn(t,x,dxdxi,xi,' str_noise ',' str_dnoisedxi ',''' options.noise_model '''),2*(' str_temp '));'];
                            case 'norm'
                                str_dsigmadxi = [str_dsigmadxi 'bsxfun(@rdivide,func_dsigma2dxi_norm(t,x,dxdxi,xi,' str_noise ',' str_dnoisedxi ',''' options.noise_model '''),2*(' str_temp '));'];
                        end
                    else
                        switch M.distribution{s,e}
                            case {'logn_median','logn','logn_mean'}
                                str_dsigmadxi = [str_dsigmadxi 'bsxfun(@rdivide,func_dsigma2dxi_logn(t,x,dxdxi,xi),2*(' str_temp '));'];
                            case 'norm'
                                str_dsigmadxi = [str_dsigmadxi 'bsxfun(@rdivide,func_dsigma2dxi_norm(t,x,dxdxi,xi),2*(' str_temp '));'];
                                
                        end
                    end
                case 'RRE'
                    if size(D(e).u,2) == 1
                        str_sigma = [str_sigma '['];
                        for k = 1:length(D(e).t)
                            str_temp = regexprep(char(M.sym.sigma{s,e}(k)),'xi_([0-9]+)','xi($1)');
                            str_sigma = strcat(str_sigma,regexprep(str_temp,'x_([0-9]+)','x(:,$1)'));
                            if k < length(D(e).t)
                                str_sigma = [str_sigma ';'];
                            else
                                str_sigma = [str_sigma '];'];
                            end
                        end
                        str_dsigmadxi = strcat(str_dsigmadxi,getStrDerivative2Terms(M.sym.sigma{s,e},x,dxdxi, xi));
                        str_dsigmadxi = [str_dsigmadxi, ';'];
                    else
                        for d = 1:size(D(e).u,2)
                            switch options.sigmas
                                case 'subpopulation-specific'
                                    M.sym.sigma{s,e} = 10.^xi(ones(1,numel(D(e).t))*D(e).sigma{s});
                                case 'time-dependent'
                                    M.sym.sigma{s,e} = 10.^xi((D(e).sigma{s}(d)));
                                case 'condition-dependent'
                                    M.sym.sigma{s,e} = 10.^xi(conditions(D(e).c(s,d)).sigma);
                                case 'time-independent'
                                    M.sym.sigma{s,e} = 10.^xi(ones(1,numel(D(e).t))*conditions(D(e).c(s,d)).sigma);
                                case 'only-one'
                                    error('TODO')
                            end
                            str = ['('];
                            for d_dim = 1:size(D(e).u,1)
                                str = [str '(u(' num2str(d_dim) ')==' num2str(D(e).u(d_dim,d)) ')'];
                                if d_dim < size(D(e).u,1)
                                    str = [str ' & '];
                                end
                            end
                            str = [str ')*'];
                            str_sigma = [strcat(str_sigma,str) '['];
                            str_dsigmadxi = strcat(str_dsigmadxi,str);
                            str_dsigmadxi = strcat(str_dsigmadxi,getStrDerivative2Terms(M.sym.sigma{s,e},x,dxdxi, xi));
                            if d < size(D(e).u,2)
                                str_dsigmadxi = [str_dsigmadxi ' ... \n \t + '];
                            end
                            for k = 1:length(D(e).t)
                                str_temp = regexprep(char(M.sym.sigma{s,e}(k)),'xi_([0-9]+)','xi($1)');
                                str_sigma = strcat(str_sigma,regexprep(str_temp,'x_([0-9]+)','x(:,$1)'));
                                if k < length(D(e).t)
                                    str_sigma = [str_sigma ';'];
                                else
                                    str_sigma = [str_sigma ']'];
                                end
                            end
                            
                            if d < size(D(e).u,2)
                                str_sigma = [str_sigma ' + ...\n\t'];
                            else
                                str_sigma = [str_sigma ';'];
                                str_dsigmadxi = [str_dsigmadxi ';'];
                                
                            end
                        end
                    end
            end
        end
        
        str_distribution = ['M.distribution{s,e} = ''' M.distribution{s,e} ''''];
        fprintf(fid,['%% Subpopulation ' num2str(s) ' \n']);
        fprintf(fid,['%% Experiment ' num2str(e) ' \n']);
        fprintf(fid,['s=' num2str(s) '; e=' num2str(e) ';\n']);
        str_meanind = ['M.mean_ind{s,e} = [' ];
        str_varind = ['M.var_ind{s,e} = [' ]  ;
        str_wind = ['M.w_ind{s,e} = [' ]  ;
        for k = 1:length(M.mean_ind{s,e})
            str_meanind = strcat(str_meanind, num2str(M.mean_ind{s,e}(k)));
            if k < length(M.mean_ind{s,e})
                str_meanind = [str_meanind, ','];
            else
                str_meanind = [str_meanind, '];'];
            end
        end
        % var_ind
        if isempty(M.var_ind{s,e})
            str_varind = [str_varind '];'];
        else
            for k = 1:length(M.var_ind{s,e})
                str_varind = strcat(str_varind, num2str(M.var_ind{s,e}(k)));
                if k < length(M.var_ind{s,e})
                    str_varind = [str_varind, ','];
                else
                    str_varind = [str_varind, '];'];
                end
                
            end
        end
        % w_ind
        if isempty(M.w_ind{s,e})
            str_wind = [str_wind '];'];
        else
            for k = 1:length(M.w_ind{s,e})
                str_wind = strcat(str_wind, num2str(M.w_ind{s,e}(k)));
                if k < length(M.w_ind{s,e})
                    str_wind = [str_wind, ','];
                else
                    str_wind = [str_wind, '];'];
                end
                
            end
        end
        fprintf(fid,[str_meanind '\n']);
        fprintf(fid,[str_varind '\n']);
        fprintf(fid,[str_wind '\n']);
        fprintf(fid,[str_mu '\n']);
        fprintf(fid,[str_dmudxi '\n\n']);
        fprintf(fid,[str_sigma '\n']);
        fprintf(fid,[str_dsigmadxi '\n\n']);
        fprintf(fid,[str_w '\n']);
        fprintf(fid,[str_dwdxi '\n']);
        fprintf(fid,[str_distribution ';\n\n']);
        
        fprintf(fid,['M.u{s,e} = [']);
        for k = 1:length(M.u{s,e})
            fprintf(fid,num2str(M.u{s,e}(k)));
            if k < length(M.u{s,e})
                fprintf(fid,';');
            else
                fprintf(fid,'];\n');
            end
        end
        
        if options.replicates
            % consider replicates individually
            rs = 1:length(D(e).replicate);
        else
            % consider scaled and merged replicates
            rs = 1;
        end
        for r=rs
            fprintf(fid,['r=' num2str(r) ';\n']);
            fprintf(fid,[str_s{r} '\n']);
            fprintf(fid,[str_b{r} '\n']);
            fprintf(fid,[str_dsdxi{r} '\n']);
            fprintf(fid,[str_dbdxi{r} '\n']);
        end
    end
end

%% write parameter names in file
if options.write_parameters
    fprintf(fid, '\n\nparameters.name = {');
    str_max = 'parameters.max = [';
    str_min = 'parameters.min = [';
    str_constr_A = 'parameters.constraints.A = [';
    
    for k = 1:length(parameters.name)
        fprintf(fid,['''' regexprep(parameters.name{k},'\\','\\\\') '''']);
        str_max = strcat(str_max,num2str(parameters.max(k)));
        str_min = strcat(str_min,num2str(parameters.min(k)));
        if isfield(parameters,'constraints')
            str_constr_A = strcat(str_constr_A,num2str(parameters.constraints.A(k)));
        end
        
        if k < length(parameters.name)
            fprintf(fid,',...\n');
            str_max = [str_max ';'];
            str_min = [str_min ';'];
            str_constr_A = [str_constr_A ','];
        else
            fprintf(fid,'};\n');
            str_max = [str_max '];'];
            str_min = [str_min '];'];
            str_constr_A = [str_constr_A '];'];
        end
        
        
    end
    fprintf(fid, 'parameters.number = length(parameters.name);\n');
    fprintf(fid,[str_max '\n']);
    fprintf(fid,[str_min '\n']);
    if isfield(parameters,'constraints')
        fprintf(fid,[str_constr_A '\n']);
        str_constr_b = ['parameters.constraints.b = [' num2str(parameters.constraints.b) '];\n'];
        fprintf(fid,[str_constr_b '\n']);
    end
end
% Close file
fclose(fid);
% Rehash to ensure that function is known / used
rehash
disp('File generation done!')

% assing ouput
if nargout >= 1
    varargout{1} = M;
end
if nargout >= 2
    varargout{2} = conditions;
end
end


function retstr = replace_xi_x_u(symexpr)

retstr = '[';
for s1 = 1:size(symexpr,1)
    for s2 = 1:size(symexpr,2)
        retstr = strcat(retstr,regexprep(char(symexpr(s1,s2)),'xi_([0-9]+)','xi($1)'));
        retstr = regexprep(retstr,'u_([0-9]+)','u($1)');
        retstr = regexprep(retstr,'x_([0-9]+)','x($1)');
        if s2 < size(symexpr,2)
            retstr = [retstr ', '];
        end
    end
    if s1 < size(symexpr,1)
        if size(symexpr,2) > 1
            retstr = [retstr ';...\n\t'];
        else
            retstr = [retstr ';'];
        end
    end
end
retstr = [retstr ']'];

end

function str_dzdxi = getStrDerivative2Terms(sym_expr, x, dxdxi, xi)

str_dzdxi = 'bsxfun(@plus, [';

%% first term of the derivative
first_expr = jacobian(sym_expr,x)*dxdxi;
for k = 1:length(first_expr)
    if ~isempty(strfind(char(first_expr(k)),'/'))
        str_temp = regexprep(char(first_expr(k)),'([^/])+/([^/])+','bsxfun(@rdivide, $1, $2)');
        str_temp = regexprep(str_temp,'x_([0-9]+)','x(:,$1)');
        str_temp = regexprep(str_temp,'u_([0-9]+)','u(:,$1)');
    else
        str_temp = regexprep(char(first_expr(k)),'x_([0-9]+)','x(:,$1)');
        str_temp = regexprep(str_temp,'u_([0-9]+)','u(:,$1)');
    end
    str_dzdxi = strcat(str_dzdxi, regexprep(str_temp,'dxdxi_([0-9]+)','permute(dxdxi($1,:,:),[3,2,1])'));
    if k < length(first_expr)
        str_dzdxi = [str_dzdxi '; '];
    end
end
str_dzdxi = [str_dzdxi '],...\n\t '];
%str_dzdxi = [str_dzdxi '],...\n\t ['];
second_expr = jacobian(sym_expr,xi);
str_dzdxi = strcat(str_dzdxi,replace_xi_x_u(second_expr));
str_dzdxi = [str_dzdxi ')'];

% %% second term of derivative
% second_expr = jacobian(sym_expr,xi);
% for s1 = 1:size(second_expr,1)
%     for s2 = 1:size(second_expr,2)
%         str_dzdxi = strcat(str_dzdxi,regexprep(char(second_expr(s1,s2)),'xi_([0-9]+)','xi($1)'));
%         if s2 < size(second_expr,2)
%             str_dzdxi = [str_dzdxi ', '];
%         end
%     end
%     if s1 < size(second_expr,1)
%         str_dzdxi = [str_dzdxi ';...\n\t'];
%     end
% end
% str_dzdxi = [str_dzdxi '])'];

end

function str_dzdxi = getStrDerivative3Terms(deriv_name, sym_expr, s, e,  x, dxdxi, sigma, dsigmadxi, xi)

str_dzdxi = ['M.' deriv_name '{s,e} = @(t,x,dxdxi,sigma,dsigmadxi,xi,u) bsxfun(@plus, ['];
%% first term of derivative
first_expr = jacobian(sym_expr{s,e},x)*dxdxi;
for k = 1:length(first_expr)
    if ~isempty(strfind(char(first_expr(k)),'/'))
        str_temp = regexprep(char(first_expr(k)),'([^/])+/([^/])+','bsxfun(@rdivide, $1, $2)');
        str_temp = regexprep(str_temp,'x_([0-9]+)','x(:,$1)');
    else
        str_temp = regexprep(char(first_expr(k)),'x_([0-9]+)','x(:,$1)');
    end
    str_dzdxi = strcat(str_dzdxi, regexprep(str_temp,'dxdxi_([0-9]+)','permute(dxdxi($1,:,:),[3,2,1])'));
    if k < length(first_expr)
        str_dzdxi = [str_dzdxi '; '];
    end
end
str_dzdxi = [str_dzdxi '],...\n\t'];

%% second term of derivative
second_expr = jacobian(sym_expr{s,e},sigma)*dsigmadxi;
str_dzdxi = [str_dzdxi, 'bsxfun(@plus,['];
for k = 1:length(second_expr)
    if ~isempty(strfind(char(second_expr(k)),'*'))
        str_dzdxi= [str_dzdxi,regexprep(char(second_expr(k)),'([^/])+*([^/])+','bsxfun(@times, $1, $2)')];
    else
        str_dzdxi = strcat(str_dzdxi, char(second_expr(k)));
    end
    if k < length(second_expr)
        str_dzdxi = [str_dzdxi '; '];
    end
end
str_dzdxi = [str_dzdxi '],...\n\t '];

%% third term
third_expr = jacobian(sym_expr{s,e},xi);
str_dzdxi = strcat(str_dzdxi,replace_xi_x_u(third_expr));
str_dzdxi = [str_dzdxi '));'];
end

% function strnoise = getStrNoise()
%   if options.measurement_noise
%                             str_noise = '[';
%                             for k = 1:D(e).n_dim
%                              str_noise = strcat(str_noise,regexprep(char(M.sym.sigma_noise{e}(k).^2),'xi_([0-9]+)','xi($1)'));
%                              str_noise = regexprep(str_noise,'u_([0-9]+)','u($1)');
%                              if k < D(e).n_dim
%                                 str_noise = [str_noise ';'];
%                              else
%                                 str_noise = [str_noise ']'];
%                              end
%                             end
%
%                              str_dnoisedxi = '[';
%                              M.sym.dnoisedxi{e} = jacobian(M.sym.sigma_noise{e}.^2,xi);
%                              for l = 1:D(e).n_dim
%                                 for k = 1:length(M.sym.dnoisedxi{e})
%                                  str_dnoisedxi = strcat(str_dnoisedxi,regexprep(char(M.sym.dnoisedxi{e}(l,k)),'xi_([0-9]+)','xi($1)'));
%                                  str_dnoisedxi = regexprep(str_dnoisedxi,'u_([0-9]+)','u($1)');
%                                  if k<size(M.sym.dnoisedxi{e},2)
%                                      str_dnoisedxi = [str_dnoisedxi ','];
%                                  elseif k==size(M.sym.dnoisedxi{e},2) && l < D(e).n_dim
%                                      str_dnoisedxi = [str_dnoisedxi ';...\n'];
%                                  elseif k==size(M.sym.dnoisedxi{e},2) && l == D(e).n_dim
%                                      str_dnoisedxi = [str_dnoisedxi ']'];
%                                  end
%                                 end
%                              end
%                              str_sigma = ['M.Sigma{s,e} = @(t,x,xi,u) func_Sigma_logn(t,x,xi,' num2str(D(e).n_dim)...
%                                  ',' str_noise ');'];
%                              str_dsigmadxi = ['M.dSigmadxi{s,e} = @(t,x,dxdxi,xi,u) func_dSigmadxi_logn(t,x,dxdxi,xi,' num2str(D(e).n_dim)...
%                                  ',' str_noise ',' str_dnoisedxi ');'];
%                         else
%                             str_sigma = ['M.Sigma{s,e} = @(t,x,xi,u) func_Sigma_logn(t,x,xi,' num2str(D(e).n_dim) ');'];
%                             str_dsigmadxi = ['M.dSigmadxi{s,e} = @(t,x,dxdxi,xi,u) func_dSigmadxi_logn(t,x,dxdxi,xi,' num2str(D(e).n_dim) ');'];
%                         end
%                     case 'norm'
%                         if options.measurement_noise
%                              str_noise = regexprep(char(M.sym.sigma_noise{e}),'xi_([0-9]+)','xi($1)');
%                              str_noise = regexprep(str_noise,'u_([0-9]+)','u($1)');
%
%                              str_dnoisedxi = '[';
%                              M.sym.dnoisedxi{e} = jacobian(M.sym.sigma_noise{e},xi);
%                                 for k = 1:length(M.sym.dnoisedxi{e})
%                                  str_dnoisedxi = strcat(str_dnoisedxi,regexprep(char(M.sym.dnoisedxi{e}(k)),'xi_([0-9]+)','xi($1)'));
%                                  str_dnoisedxi = regexprep(str_dnoisedxi,'u_([0-9]+)','u($1)');
%                                  if k<length(M.sym.dnoisedxi{e})
%                                      str_dnoisedxi = [str_dnoisedxi ';'];
%                                  else
%                                      str_dnoisedxi = [str_dnoisedxi ']'];
%                                  end
%                                 end
%                              str_sigma = ['M.Sigma{s,e} = @(t,x,xi,u) func_Sigma_norm(t,x,xi,' num2str(D(e).n_dim)...
%                                  ',' str_noise ');'];
%                              str_dsigmadxi = ['M.dSigmadxi{s,e} = @(t,x,dxdxi,xi,u) func_dSigmadxi_norm(t,x,dxdxi,xi,' num2str(D(e).n_dim)...
%                                  ',' str_noise ',' str_dnoisedxi ','' options.noise_model '');'];
%
%
% end