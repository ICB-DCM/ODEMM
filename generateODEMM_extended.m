function varargout = generateODEMM_extended(D,M,parameters,conditions,varargin)
% This function generates a file that defines the ODE-constrained mixture model.
%
% USAGE:
% M = generateODEMM(D,M,parameters,conditions,options)
%
% Parameters:
% M: model struct
% D: data struct
% parameters: parameters struct
% conditions: conditions struct obtained by collectConditions.m
% varargin:
% options: (options for the generation)
%
% Required fields of M:
% name: name of the model
% model: simulation file with input (T,theta,u) (e.g., generated by
%   amiwrap of the toolbox AMICI), the first output needs to be
%   the status of thesimulation (whether it failed or not) the 4th the
%   simulation output, and the 6th the sensitivities
% sim_type: simulation type (''RRE' for a mechanistic description of the
%   mean, e.g., by reaction rate equations, ''HO'' for a mechanistic description
%   of the mean and covariance, e.g., by moment-closure approximation or
%   sigma-point approximation)
% n_subpop: number of subpopulations
% distribution{s,e}: distribution assumption  \n
%   = ''norm'' for normal distribution assumption \n
%   = ''logn_median'' for log-normal distribution assumption when mean of
%                   simulation linked to median of distribution \n
%   = ''logn_mean'' for log-normal distribution assumption when mean of
%                   simulation is linked to mean of distribution \n
%  mean_ind{s,e}: indices of simulation output describing the mean of
%               the measurand(s) of experiment e
%  var_ind{s,e}:  indices of simulation output describing the variance (empty
%               if RREs used)
%  u{s,e}: input vector describing differences between subpopulations
%               and experiments
%  sym: symbolic description of properties of the model with fields
%      * w{s,e}: weights of subpopulation s in experiment e
%      * theta: parameter needed for simulation of individual
%                   subpopulations
%      * scaling{r,e}: scaling factor for replicate r in experiment e, if the
%                     replicates are not considered seperately, use r=1
%      * offset{r,e}: offset parameter for replicate r in experiment e
%
% Optional fields of options:
%     write_parameter: write parameter definition in file (true by
%     default)
%     measurement_noise: if measurement noise is included\n
%                = true\n
%                = false (default)
%     replicates: if individual replicates are modeled\N
%               = true \n
%               = false (default)
%     sigmas: parametrization of the variance in case of using only a
%     mechanistic description of the mean \n
%         = ''condition-dependent'': (default) assign sigma for every time point \n
%         = ''time-independent'':  sigma stays the same for subpopulation
%                       and some dosage \n
%         = ''only-one'': only one sigma for everything
%
% Required fields of D:
% conditions: obtained by collectConditions.m


% todo: parameters not needed if they are not written in the file

options.write_parameters = true;
options.measurement_noise = false;
options.replicates = false;
options.path = [];
if nargin == 5
    options = setdefault(varargin{1},options);
end

%% check M fields
if ~isfield(M,'mean_ind')
    error('For M the field mean_ind needs to be defined!');
end
switch M.sim_type
    case 'RRE'
        for s = 1:M.n_subpop
            for e = 1:length(D)
                M.w_ind{s,e} = [];
                M.var_ind{s,e} = [];
            end
        end
    case 'HO'
        if ~isfield(M,'var_ind')
            error('For M the field var_ind needs to be defined!');
        end
        for s = 1:M.n_subpop
            for e = 1:length(D)
                M.w_ind{s,e} = [];
            end
        end
    case 'MCM'
        if ~isfield(M,'w_ind')
            error('For M the field w_ind needs to be defined!');
        end
        if ~isfield(M,'var_ind')
            error('For M the field var_ind needs to be defined!');
        end
    otherwise
        error('M.sim_type needs to be ''HO'', ''RRE'' or ''MCM''!');
end

if strcmp(M.distribution{s,e},'students_t')
    disp('Extend parameter vector by nu for student''s t distribution.');
    parameters.name{end+1} = 'log_{10}(\nu)';
    parameters.min(end+1) = log10(2);
    parameters.max(end+1) = 2;
    parameters.number = parameters.number+1;
    nu_ind = parameters.number;
    disp('Flag to write parameters in file set to true.');
    options.write_parameters = true;
end

disp(['Start generation of ODEMM for ' M.name '...']);
dimension_all = 0;
for e = 1:length(D)
    for s = 1:M.n_subpop
        num_w = 0;
        if strcmp(M.sim_type,'MCM')
            num_w = M.n_subpop-1;
        end
        if length(M.mean_ind{s,e})+length(M.var_ind{s,e})+num_w > dimension_all
            dimension_all = length(M.mean_ind{s,e})+...
                length(M.var_ind{s,e})+num_w;
        end
    end
end
xi = sym(zeros(parameters.number,1));
for i = 1:parameters.number
    xi(i) = sym(['xi_' num2str(i,'%d')]);
end
x =  sym(zeros(dimension_all,1));
dxdxi = sym(zeros(dimension_all,1));
sigma = sym('sigma');
dsigmadxi = sym('dsigmadxi');
rho = sym('rho');
drhodxi = sym('drhodxi');

for i = 1:dimension_all
    x(i) = sym(['x_' num2str(i,'%d')]);
    dxdxi(i) = sym(['dxdxi_' num2str(i,'%d')]);
end

%% theta
str_theta = ['M.theta = @(xi,u) '];
str_theta = strcat(str_theta,strcat(replace_xi_x_u(M.sym.theta),';'));
%% dthetadxi
M.sym.dthetadxi = jacobian(M.sym.theta, xi);
str_dthetadxi = ['M.dthetadxi= @(xi,u) '];
str_dthetadxi = strcat(str_dthetadxi,strcat(replace_xi_x_u(M.sym.dthetadxi),';'));

for e = 1:length(D)
    for s = 1:M.n_subpop
        %% initialize sigma/rho
        switch M.sim_type
            case 'RRE'
                switch M.distribution{s,e}
                    case {'norm','logn_mean','logn_median'}
                        switch options.sigmas
                            case 'subpopulation-specific'
                                if D(e).n_dim == 1
                                    M.sym.sigma{s,e} = 10.^xi(ones(1,numel(D(e).t))*D(e).sigma{s});
                                else
                                    M.sym.ind{s,e} = sym(D(e).Sigma{s});
                                end
                            case 'time-dependent'
                                if D(e).n_dim == 1
                                    M.sym.sigma{s,e} = 10.^xi(D(e).sigma{s});
                                else
                                    M.sym.ind{s,e} = sym(D(e).Sigma{s});
                                end
                                %                             case 'condition-dependent'
                                %                                 if D(e).n_dim == 1
                                %                                     M.sym.sigma{s,e} = 10.^xi(conditions(D(e).c(s,1)).sigma);
                                %                                 else
                                %                                     M.sym.ind{s,e} = sym(conditions(D(e).c(s,1)).Sigma);
                                %                                 end
                            case {'time-independent','only-one'}
                                M.sym.sigma{s,e} = 10.^xi(ones(1,numel(D(e).t))*conditions(D(e).c(s,1)).sigma);
                        end
                    case 'neg_binomial'
                        switch options.rhos
                            case 'subpopulation-specific'
                                M.sym.rho{s,e} = xi(ones(1,numel(D(e).t))*D(e).rho{s});
                            case 'time-dependent'
                                M.sym.rho{s,e} = xi(D(e).rho{s});
                                %                             case 'condition-dependent'
                                %                                 M.sym.rho{s,e} = xi(conditions(D(e).c(s,1)).rho);
                            case {'time-independent','only-one'}
                                M.sym.rho{s,e} = xi(ones(1,numel(D(e).t))*conditions(D(e).c(s,1)).rho);
                            otherwise
                                error('case not defined');
                        end
                        
                end
            case {'HO','MCM'}
                % definition of variance parameters and incorporation of measurement noise
                switch M.distribution{s,e}
                    case 'norm'
                        if options.measurement_noise
                            M.sym.sigma{s,e} = sqrt(x(2)+M.sym.sigma_noise{e}.^2);
                        else
                            M.sym.sigma{s,e} = sqrt(x(2));
                        end
                    case 'logn_median'
                        if options.measurement_noise
                            switch options.noise_model
                                case 'multiplicative'
                                    M.sym.sigma{s,e} = sqrt(log(x(2)/(x(1)^2)+1)+M.sym.sigma_noise{e}.^2);
                                case 'additive'
                                    M.sym.sigma{s,e} = sqrt(log((x(2)+M.sym.sigma_noise{e}.^2)/(x(1)^2)+1));
                            end
                        else
                            M.sym.sigma{s,e} = sqrt(log(x(2)/(x(1)^2)+1));
                        end
                    case 'logn_mean'
                        if options.measurement_noise
                            M.sym.sigma{s,e} = sqrt(log(x(2)/(x(1)^2)+1)+M.sym.sigma_noise{e}.^2);
                        else
                            M.sym.sigma{s,e} = sqrt(log(x(2)/(x(1)^2)+1));
                        end
                    case 'neg_binomial'
                        if options.measurement_noise
                            error('to do: neg binomial with measurement noise?')
                        else
                            M.sym.rho{s,e} = 1-x(1)/x(2);
                        end
                    case 'students_t'
                        M.sym.nu{s,e} = 10.^xi(nu_ind)*ones(size(D(e).t(:)));
                        if options.measurement_noise
                            error('to do: student t measurement noise')
                        end
                end
        end
        
        %% initialize mean parameters
        switch M.distribution{s,e}
            case {'norm','students_t'}
                M.sym.mu{s,e} = x(1);
            case 'logn_median'
                M.sym.mu{s,e} = log(x(1));
            case 'logn_mean'
                M.sym.mu{s,e} = log(x(1))-(sigma.^2)/2;
            case 'neg_binomial'
                M.sym.tau{s,e} = (1-rho).*x(1)./rho;
        end
    end
end

%% CONSTRUCT SIMULATION FILE
clear([options.path 'ODEMM_' M.name '.m']);
% Open file
fid = fopen([options.path 'ODEMM_' M.name '.m'],'w');
% Construct string
fprintf(fid,['%%%% Definition of model\n']);
fprintf(fid,['M.name = ''' M.name '''; \n']);
fprintf(fid,['M.n_subpop = ' num2str(M.n_subpop) '; \n']);
fprintf(fid,['M.model = ' char(M.model) '; \n']);
fprintf(fid,[str_theta '\n']);
fprintf(fid,[str_dthetadxi '\n\n']);

%% generate strings
for s = 1:M.n_subpop
    for e = 1:length(D)
        disp(['...generate definition of subpopulation ' num2str(s) ' in experiment ' num2str(e) '...']);
        switch M.sim_type
            case {'RRE','HO'}
                %% w
                str_w =['M.w{s,e} = @(t,x,xi,u) '];
                str_w = strcat(str_w,strcat(replace_xi_x_u(M.sym.w{s,e}),';'));
                %% dwdxi
                str_dwdxi = strcat(['M.dwdxi{s,e} = @(t,x,dxdxi,xi,u)'], getStrDerivative2Terms(M.sym.w{s,e}, x, dxdxi, xi));
                str_dwdxi = [str_dwdxi, ';'];
                str_dwdxi = regexprep(str_dwdxi,'u_([0-9]+)','u($1)');
            case 'MCM'
                if s < M.n_subpop
                    ind_w = length(M.mean_ind{s,e}) + length(M.var_ind{s,e}) +1;
                    str_w = ['M.w{s,e} = @(t,x,xi,u) x(:,' num2str(ind_w) ');'];
                    str_dwdxi = ['M.dwdxi{s,e} = @(t,x,dxdxi,xi,u) permute(dxdxi(' num2str(ind_w) ',:,:),[3,2,1]);'];
                else
                    ind_w = length(M.mean_ind{s,e}) + length(M.var_ind{s,e}) +1;
                    str_w = 'M.w{s,e} = @(t,x,xi,u) 1';
                    str_dwdxi = 'M.dwdxi{s,e} = @(t,x,dxdxi,xi,u)' ;
                    for z = 1:M.n_subpop-1
                        str_w = strcat(str_w,['-x(:,' num2str(ind_w) ')']);
                        if M.n_subpop > 2
                            error('TODO')
                        else
                            str_dwdxi = strcat(str_dwdxi,['-permute(dxdxi('  num2str(ind_w) ',:,:),[3,2,1])']);
                        end
                        ind_w = ind_w+1;
                    end
                    str_w = strcat(str_w,';');
                    str_dwdxi = strcat(str_dwdxi,';');
                end
        end
        if D(e).n_dim == 1 || strcmp(M.distribution{s,e},'students_t')
            switch M.distribution{s,e}
                case {'norm','logn_mean','logn_median','students_t'}
                    %% mu
                    str_mu =['M.mu{s,e} = @(t,x,sigma,xi,u) ['];
                    str_temp = regexprep(char(M.sym.mu{s,e}),'xi_([0-9]+)','xi($1)');
                    str_temp = regexprep(str_temp,'\^','.^');
                    str_mu = strcat(str_mu,regexprep(str_temp,'x_([0-9]+)','x(:,$1)'));
                    str_mu = [str_mu '];'];
                    %% dmudxi
                    str_dmudxi = getStrDerivative3Terms('dmudxi',M.sym.mu,s,e,x,dxdxi,sigma,dsigmadxi,xi);
                case 'neg_binomial'
                    %% tau
                    str_tau =['M.tau{s,e} = @(t,x,rho,xi,u) ['];
                    str_temp = regexprep(char(M.sym.tau{s,e}),'xi_([0-9]+)','xi($1)');
                    str_temp = regexprep(str_temp,'\^','.^');
                    str_temp = regexprep(str_temp,'\*','.*');
                    str_temp = regexprep(str_temp,'\/','./');
                    str_tau = strcat(str_tau,regexprep(str_temp,'x_([0-9]+)','x(:,$1)'));
                    str_tau = [str_tau '];'];
                    %% dtaudxi
                    str_dtaudxi = 'M.dtaudxi{s,e} = @(t,x,dxdxi,rho,drhodxi,xi,u) bsxfun(@times,rho.^(-2), bsxfun(@times,permute(dxdxi(1,:,:),[3,2,1]),rho.*(1-rho))-bsxfun(@times,x(:,1),drhodxi));';
            end
        else % multivariate
            %% mu
            str_mu =['M.mu{s,e} = @(t,x,Sigma,xi,u) ['];
            switch M.distribution{s,e}
                case 'logn_mean'
                    for n = 1:D(e).n_dim
                        str_mu = [str_mu 'log(x(:,' num2str(n) ')) - 0.5*Sigma(:,' num2str(n) ',' num2str(n) ')'];
                        if n < D(e).n_dim
                            str_mu = [str_mu ',...\n'];
                        else
                            str_mu = [str_mu '];\n'];
                        end
                    end
                case 'logn_median'
                    for n = 1:D(e).n_dim
                        str_mu = [str_mu 'log(x(:,' num2str(n) '))'];
                        if n < D(e).n_dim
                            str_mu = [str_mu ','];
                        else
                            str_mu = [str_mu '];\n'];
                        end
                    end
                case {'norm','students_t'}
                    for n = 1:D(e).n_dim
                        str_mu = [str_mu 'x(:,' num2str(n) ')'];
                        if n < D(e).n_dim
                            str_mu = [str_mu ','];
                        else
                            str_mu = [str_mu '];\n'];
                        end
                    end
            end
            %% dmudxi
            str_dmudxi = ['M.dmudxi{s,e} = @(t,x,dxdxi,Sigma,dSigmadxi,xi,u) func_dmudxi_' M.distribution{s,e}...
                '(t,x,dxdxi,Sigma,dSigmadxi,xi,u,' num2str(D(e).n_dim) ');'];
        end
        
        if options.replicates
            % consider replicates individually
            rs = 1:length(D(e).replicate);
        else
            % consider scaled and merged replicates
            rs = 1;
        end
        for r = rs
            %% s,b
            str_s{r} =  'M.scaling{r,e} = @(xi,u) ';
            str_s{r} = strcat(str_s{r},strcat(replace_xi_x_u(M.sym.scaling{r,e}),';'));
            str_b{r} =  'M.offset{r,e} = @(xi,u) ';
            str_b{r} = strcat(str_b{r},strcat(replace_xi_x_u(M.sym.offset{r,e}),';'));
            
            str_dsdxi{r} = 'M.dscalingdxi{r,e} = @(xi,u) ';
            str_dbdxi{r} = 'M.doffsetdxi{r,e} = @(xi,u) ';
            M.sym.dscalingdxi{r,e} = jacobian(M.sym.scaling{r,e},xi);
            M.sym.doffsetdxi{r,e} = jacobian(M.sym.offset{r,e},xi);
            str_dsdxi{r} = strcat(str_dsdxi{r},strcat(replace_xi_x_u(M.sym.dscalingdxi{r,e}),';'));
            str_dbdxi{r} = strcat(str_dbdxi{r},strcat(replace_xi_x_u(M.sym.doffsetdxi{r,e}),';'));
        end
        
        %% dsigma dsigmadxi
        if D(e).n_dim > 1 || strcmp(M.distribution{s,e},'students_t')
            switch M.sim_type
                case {'HO','MCM'}
                    switch M.distribution{s,e}
                        case {'logn','logn_mean','logn_median'}
                            if options.measurement_noise
                                str_noise = '[';
                                for k = 1:D(e).n_dim
                                    str_noise = strcat(str_noise,regexprep(char(M.sym.sigma_noise{e}(k).^2),'xi_([0-9]+)','xi($1)'));
                                    str_noise = regexprep(str_noise,'u_([0-9]+)','u($1)');
                                    if k < D(e).n_dim
                                        str_noise = [str_noise ';'];
                                    else
                                        str_noise = [str_noise ']'];
                                    end
                                end
                                str_dnoisedxi = '[';
                                M.sym.dnoisedxi{e} = jacobian(M.sym.sigma_noise{e}.^2,xi);
                                for l = 1:D(e).n_dim
                                    for k = 1:length(M.sym.dnoisedxi{e})
                                        str_dnoisedxi = strcat(str_dnoisedxi,regexprep(char(M.sym.dnoisedxi{e}(l,k)),'xi_([0-9]+)','xi($1)'));
                                        str_dnoisedxi = regexprep(str_dnoisedxi,'u_([0-9]+)','u($1)');
                                        if k<size(M.sym.dnoisedxi{e},2)
                                            str_dnoisedxi = [str_dnoisedxi ','];
                                        elseif k==size(M.sym.dnoisedxi{e},2) && l < D(e).n_dim
                                            str_dnoisedxi = [str_dnoisedxi ';...\n'];
                                        elseif k==size(M.sym.dnoisedxi{e},2) && l == D(e).n_dim
                                            str_dnoisedxi = [str_dnoisedxi ']'];
                                        end
                                    end
                                end
                                str_sigma = ['M.Sigma{s,e} = @(t,x,xi,u) func_Sigma_logn(t,x,xi,' num2str(D(e).n_dim)...
                                    ',' str_noise ,',''' options.noise_model ''');'];
                                str_dsigmadxi = ['M.dSigmadxi{s,e} = @(t,x,dxdxi,xi,u) func_dSigmadxi_logn(t,x,dxdxi,xi,' num2str(D(e).n_dim)...
                                    ',' str_noise ',' str_dnoisedxi ',''' options.noise_model ''');'];
                            else
                                str_sigma = ['M.Sigma{s,e} = @(t,x,xi,u) func_Sigma_logn(t,x,xi,' num2str(D(e).n_dim) ');'];
                                str_dsigmadxi = ['M.dSigmadxi{s,e} = @(t,x,dxdxi,xi,u) func_dSigmadxi_logn(t,x,dxdxi,xi,' num2str(D(e).n_dim) ');'];
                            end
                        case {'norm','students_t'}
                            if options.measurement_noise
                                str_noise = '[';
                                for k = 1:D(e).n_dim
                                    str_noise = strcat(str_noise,regexprep(char(M.sym.sigma_noise{e}(k).^2),'xi_([0-9]+)','xi($1)'));
                                    str_noise = regexprep(str_noise,'u_([0-9]+)','u($1)');
                                    if k < D(e).n_dim
                                        str_noise = [str_noise ';'];
                                    else
                                        str_noise = [str_noise ']'];
                                    end
                                end
                                str_dnoisedxi = '[';
                                M.sym.dnoisedxi{e} = jacobian(M.sym.sigma_noise{e}.^2,xi);
                                for l = 1:D(e).n_dim
                                    for k = 1:length(M.sym.dnoisedxi{e})
                                        str_dnoisedxi = strcat(str_dnoisedxi,regexprep(char(M.sym.dnoisedxi{e}(l,k)),'xi_([0-9]+)','xi($1)'));
                                        str_dnoisedxi = regexprep(str_dnoisedxi,'u_([0-9]+)','u($1)');
                                        if k<size(M.sym.dnoisedxi{e},2)
                                            str_dnoisedxi = [str_dnoisedxi ','];
                                        elseif k==size(M.sym.dnoisedxi{e},2) && l < D(e).n_dim
                                            str_dnoisedxi = [str_dnoisedxi ';...\n'];
                                        elseif k==size(M.sym.dnoisedxi{e},2) && l == D(e).n_dim
                                            str_dnoisedxi = [str_dnoisedxi ']'];
                                        end
                                    end
                                end
                                str_sigma = ['M.Sigma{s,e} = @(t,x,xi,u) func_Sigma_' M.distribution{s,e} '(t,x,xi,' num2str(D(e).n_dim)...
                                    ',' str_noise ',''' options.noise_model ''');'];
                                str_dsigmadxi = ['M.dSigmadxi{s,e} = @(t,x,dxdxi,xi,u) func_dSigmadxi_' M.distribution{s,e} '(t,x,dxdxi,xi,' num2str(D(e).n_dim)...
                                    ',' str_noise ',' str_dnoisedxi ',''' options.noise_model ''');'];
                            else
                                str_sigma = ['M.Sigma{s,e} = @(t,x,xi,u) func_Sigma_' M.distribution{s,e} '(t,x,xi,' num2str(D(e).n_dim) ');'];
                                str_dsigmadxi = ['M.dSigmadxi{s,e} = @(t,x,dxdxi,xi,u) func_dSigmadxi_' M.distribution{s,e} '(t,x,dxdxi,xi,' num2str(D(e).n_dim) ');'];
                            end
                            if strcmp(M.distribution{s,e},'students_t')
                                
                                %% w
                                str_nu =['M.nu{s,e} = @(t,x,xi,u) '];
                                str_nu = strcat(str_nu,strcat(replace_xi_x_u(M.sym.nu{s,e}),';'));
                                %% dwdxi
                                str_dnudxi = strcat(['M.dnudxi{s,e} = @(t,x,dxdxi,xi,u)'], getStrDerivative2Terms(M.sym.nu{s,e}, x, dxdxi, xi));
                                str_dnudxi = [str_dnudxi, ';'];
                                str_dnudxi = regexprep(str_dnudxi,'u_([0-9]+)','u($1)');
                                
                            end
                    end
                case 'RRE'
                    if size(D(e).u,2) == 1
                        ind = '[';
                        for l = 1:size(M.sym.ind{s,e},2)
                            for k = 1:size(M.sym.ind{s,e},1)
                                ind = strcat(ind,char(M.sym.ind{s,e}(k,l)));
                                ind = strcat(ind,',');
                            end
                        end
                        ind = strcat(ind,']');
                        if options.covariance
                            str_sigma = ['M.Sigma{s,e} = @(t,x,xi,u) func_Sigma_RRE_cov(t,x,xi,' num2str(D(e).n_dim) ', ' ind ' );'];
                            str_dsigmadxi = ['M.dSigmadxi{s,e} = @(t,x,dxdxi,xi,u) func_dSigmadxi_RRE_cov(t,x,dxdxi,xi,' num2str(D(e).n_dim) ', ' ind ');'];
                        else
                            str_sigma = ['M.Sigma{s,e} = @(t,x,xi,u) func_Sigma_RRE(t,x,xi,' num2str(D(e).n_dim) ', ' ind ' );'];
                            str_dsigmadxi = ['M.dSigmadxi{s,e} = @(t,x,dxdxi,xi,u) func_dSigmadxi_RRE(t,x,dxdxi,xi,' num2str(D(e).n_dim) ', ' ind ');'];
                        end
                    else
                        str_sigma = ['M.Sigma{s,e} = @(t,x,xi,u) '];
                        str_dsigmadxi = ['M.dSigmadxi{s,e} = @(t,x,dxdxi,xi,u) ' ];
                        for d = 1:size(D(e).u,2)
                            str = ['('];
                            for d_dim = 1:size(D(e).u,1)
                                str = [str '(u(' num2str(d_dim) ')==' num2str(D(e).u(d_dim,d)) ')'];
                                if d_dim < size(D(e).u,1)
                                    str = [str ' & '];
                                end
                            end
                            str = [str ')*'];
                            ind = '[';
                            if options.covariance
                                for l = 1:3
                                    ind = strcat(ind,num2str(D(e).Sigma{s}(l,d)));
                                    if l < 3
                                        ind = strcat(ind,',');
                                    end
                                end
                            else
                                for l = 1:2
                                    ind = strcat(ind,num2str(D(e).Sigma{s}(l,d)));
                                    if l < 2
                                        ind = strcat(ind,',');
                                    end
                                end
                            end
                            ind = strcat(ind,']');
                            if options.covariance
                                str_sigma = strcat(str_sigma,[str 'func_Sigma_RRE_cov(t,x,xi,' num2str(D(e).n_dim) ', ' ind ' )']);
                                str_dsigmadxi = strcat(str_dsigmadxi,[str ' func_dSigmadxi_RRE_cov(t,x,dxdxi,xi,' num2str(D(e).n_dim) ', ' ind ')']);
                            else
                                str_sigma = strcat(str_sigma,[str 'func_Sigma_RRE(t,x,xi,' num2str(D(e).n_dim) ', ' ind ' )']);
                                str_dsigmadxi = strcat(str_dsigmadxi,[str ' func_dSigmadxi_RRE(t,x,dxdxi,xi,' num2str(D(e).n_dim) ', ' ind ')']);
                                
                            end
                            if d < size(D(e).u,2)
                                str_sigma = strcat(str_sigma,'+');
                                str_dsigmadxi = strcat(str_dsigmadxi,'+');
                            end
                            
                        end
                        str_sigma = strcat(str_sigma,';');
                        str_dsigmadxi = strcat(str_dsigmadxi,';');
                    end
                    
            end
        else
            switch M.distribution{s,e}
                case {'logn_mean','logn_median','norm'}
                    str_sigma = ['M.sigma{s,e} = @(t,x,xi,u)\t'];
                    str_dsigmadxi = ['M.dsigmadxi{s,e} = @(t,x,dxdxi,xi,u)\t'];
                    switch M.sim_type
                        case {'HO','MCM'}
                            str_sigma = [str_sigma '['];
                            str_temp = regexprep(replace_by_bsxfun(char(M.sym.sigma{s,e})),'xi_([0-9]+)','xi($1)');
                            str_temp = regexprep(str_temp,'\^','.^');
                            str_temp = regexprep(str_temp,'x_([0-9]+)','x(:,$1)');
                            str_sigma = strcat(str_sigma,str_temp);
                            str_sigma = [str_sigma '];'];
                            % ACHTUNG HARD GECODED
                            %sw%tch M.distribution{s,e}
                            % case {'logn_median','logn_mean'}
                            if options.measurement_noise
                                str_noise = regexprep(char(M.sym.sigma_noise{e}.^2),'xi_([0-9]+)','xi($1)');
                                str_dnoisedxi = '[';
                                M.sym.dnoisedxi{e} = jacobian(M.sym.sigma_noise{e}.^2,xi);
                                for k = 1:length(M.sym.dnoisedxi{e})
                                    str_dnoisedxi = strcat(str_dnoisedxi,regexprep(char(M.sym.dnoisedxi{e}(k)),'xi_([0-9]+)','xi($1)'));
                                    str_dnoisedxi = regexprep(str_dnoisedxi,'u_([0-9]+)','u($1)');
                                    if k<size(M.sym.dnoisedxi{e},2)
                                        str_dnoisedxi = [str_dnoisedxi ','];
                                    else
                                        str_dnoisedxi = [str_dnoisedxi ']'];
                                    end
                                end
                                switch M.distribution{s,e}
                                    case {'logn_median','logn','logn_mean'}
                                        str_dsigmadxi = [str_dsigmadxi 'bsxfun(@rdivide,func_dsigma2dxi_logn(t,x,dxdxi,xi,' str_noise ',' str_dnoisedxi ',''' options.noise_model '''),2*(' str_temp '));'];
                                    case 'norm'
                                        str_dsigmadxi = [str_dsigmadxi 'bsxfun(@rdivide,func_dsigma2dxi_norm(t,x,dxdxi,xi,' str_noise ',' str_dnoisedxi ',''' options.noise_model '''),2*(' str_temp '));'];
                                end
                            else
                                switch M.distribution{s,e}
                                    case {'logn_median','logn','logn_mean'}
                                        str_dsigmadxi = [str_dsigmadxi 'bsxfun(@rdivide,func_dsigma2dxi_logn(t,x,dxdxi,xi),2*(' str_temp '));'];
                                    case 'norm'
                                        str_dsigmadxi = [str_dsigmadxi 'bsxfun(@rdivide,func_dsigma2dxi_norm(t,x,dxdxi,xi),2*(' str_temp '));'];
                                end
                            end
                        case 'RRE'
                            if size(D(e).u,2) == 1
                                str_sigma = [str_sigma '['];
                                for k = 1:length(D(e).t)
                                    str_temp = regexprep(char(M.sym.sigma{s,e}(k)),'xi_([0-9]+)','xi($1)');
                                    str_sigma = strcat(str_sigma,regexprep(str_temp,'x_([0-9]+)','x(:,$1)'));
                                    if k < length(D(e).t)
                                        str_sigma = [str_sigma ';'];
                                    else
                                        str_sigma = [str_sigma '];'];
                                    end
                                end
                                str_dsigmadxi = strcat(str_dsigmadxi,getStrDerivative2Terms(M.sym.sigma{s,e},x,dxdxi, xi));
                                str_dsigmadxi = [str_dsigmadxi, ';'];
                            else
                                for d = 1:size(D(e).u,2)
                                    switch options.sigmas
                                        case 'subpopulation-specific'
                                            M.sym.sigma{s,e} = 10.^xi(ones(1,numel(D(e).t))*D(e).sigma{s});
                                        case 'time-dependent'
                                            M.sym.sigma{s,e} = 10.^xi((D(e).sigma{s}(d)));
                                            %                                         case 'condition-dependent'
                                            %                                             M.sym.sigma{s,e} = 10.^xi(conditions(D(e).c(s,d)).sigma);
                                            %                                         case 'time-independent'
                                            %                                             M.sym.sigma{s,e} = 10.^xi(ones(1,numel(D(e).t))*conditions(D(e).c(s,d)).sigma);
                                        case 'only-one'
                                            error('TODO')
                                    end
                                    str = ['('];
                                    for d_dim = 1:size(D(e).u,1)
                                        str = [str '(u(' num2str(d_dim) ')==' num2str(D(e).u(d_dim,d)) ')'];
                                        if d_dim < size(D(e).u,1)
                                            str = [str ' & '];
                                        end
                                    end
                                    str = [str ')*'];
                                    str_sigma = [strcat(str_sigma,str) '['];
                                    str_dsigmadxi = strcat(str_dsigmadxi,str);
                                    str_dsigmadxi = strcat(str_dsigmadxi,getStrDerivative2Terms(M.sym.sigma{s,e},x,dxdxi, xi));
                                    if d < size(D(e).u,2)
                                        str_dsigmadxi = [str_dsigmadxi ' ... \n \t + '];
                                    end
                                    for k = 1:length(D(e).t)
                                        str_temp = regexprep(char(M.sym.sigma{s,e}(k)),'xi_([0-9]+)','xi($1)');
                                        str_sigma = strcat(str_sigma,regexprep(str_temp,'x_([0-9]+)','x(:,$1)'));
                                        if k < length(D(e).t)
                                            str_sigma = [str_sigma ';'];
                                        else
                                            str_sigma = [str_sigma ']'];
                                        end
                                    end
                                    
                                    if d < size(D(e).u,2)
                                        str_sigma = [str_sigma ' + ...\n\t'];
                                    else
                                        str_sigma = [str_sigma ';'];
                                        str_dsigmadxi = [str_dsigmadxi ';'];
                                    end
                                end
                            end
                    end
                case 'neg_binomial'
                    str_rho = ['M.rho{s,e} = @(t,x,xi,u)\t'];
                    str_drhodxi = ['M.drhodxi{s,e} = @(t,x,dxdxi,xi,u)\t'];
                    switch M.sim_type
                        case {'HO','MCM'}
                            str_rho = [str_rho '['];
                            str_temp = regexprep(replace_by_bsxfun(char(M.sym.rho{s,e})),'xi_([0-9]+)','xi($1)');
                            str_temp = regexprep(str_temp,'\^','.^');
                            str_temp = regexprep(str_temp,'x_([0-9]+)','x(:,$1)');
                            str_rho = strcat(str_rho,str_temp);
                            str_rho = [str_rho '];'];
                            
                            % derivative
                            str_drhodxi = strcat(str_drhodxi,getStrDerivative2Terms(M.sym.rho{s,e},x,dxdxi,xi));
                            str_drhodxi = regexprep(str_drhodxi,'\^','.^');
                            str_drhodxi = [str_drhodxi, ';'];
                            
                        case 'RRE'
                            str_rho = [str_rho '['];
                            for k = 1:length(D(e).t)
                                str_temp = regexprep(char(M.sym.rho{s,e}(k)),'xi_([0-9]+)','xi($1)');
                                str_rho = strcat(str_rho,regexprep(str_temp,'x_([0-9]+)','x(:,$1)'));
                                if k < length(D(e).t)
                                    str_rho = [str_rho ';'];
                                else
                                    str_rho = [str_rho '];'];
                                end
                            end
                            str_drhodxi = strcat(str_drhodxi,getStrDerivative2Terms(M.sym.rho{s,e},x,dxdxi, xi));
                            str_drhodxi = [str_drhodxi, ';'];
                    end
                case 'students_t'
                    error('case should be covered with ndim>1')
                otherwise
                    error(['Check distribution assumption, provided assumption ''' ...
                        M.distribution{s,e} ''' not covered. Only '...
                        '''neg_binomial'',''students_t'',''logn'',''norm'',''skew_t'',''skew_norm'''])
            end
        end
        
        
        str_distribution = ['M.distribution{s,e} = ''' M.distribution{s,e} ''''];
        fprintf(fid,['%% Subpopulation ' num2str(s) ' \n']);
        fprintf(fid,['%% Experiment ' num2str(e) ' \n']);
        fprintf(fid,['s=' num2str(s) '; e=' num2str(e) ';\n']);
        str_meanind = ['M.mean_ind{s,e} = [' ];
        str_varind = ['M.var_ind{s,e} = [' ]  ;
        str_wind = ['M.w_ind{s,e} = [' ]  ;
        for k = 1:length(M.mean_ind{s,e})
            str_meanind = strcat(str_meanind, num2str(M.mean_ind{s,e}(k)));
            if k < length(M.mean_ind{s,e})
                str_meanind = [str_meanind, ','];
            else
                str_meanind = [str_meanind, '];'];
            end
        end
        % var_ind
        if isempty(M.var_ind{s,e})
            str_varind = [str_varind '];'];
        else
            for k = 1:length(M.var_ind{s,e})
                str_varind = strcat(str_varind, num2str(M.var_ind{s,e}(k)));
                if k < length(M.var_ind{s,e})
                    str_varind = [str_varind, ','];
                else
                    str_varind = [str_varind, '];'];
                end
            end
        end
        % w_ind
        if isempty(M.w_ind{s,e})
            str_wind = [str_wind '];'];
        else
            for k = 1:length(M.w_ind{s,e})
                str_wind = strcat(str_wind, num2str(M.w_ind{s,e}(k)));
                if k < length(M.w_ind{s,e})
                    str_wind = [str_wind, ','];
                else
                    str_wind = [str_wind, '];'];
                end
                
            end
        end
        fprintf(fid,[str_meanind '\n']);
        fprintf(fid,[str_varind '\n']);
        fprintf(fid,[str_wind '\n']);
        switch M.distribution{s,e}
            case {'norm','logn_median','logn_mean','students_t'}
                fprintf(fid,[str_mu '\n']);
                fprintf(fid,[str_dmudxi '\n\n']);
                fprintf(fid,[str_sigma '\n']);
                fprintf(fid,[str_dsigmadxi '\n\n']);
                if strcmp( M.distribution{s,e},'students_t')
                    fprintf(fid,[str_nu '\n']);
                    fprintf(fid,[str_dnudxi '\n\n']);
                end
            case 'neg_binomial'
                fprintf(fid,[str_tau '\n']);
                fprintf(fid,[str_dtaudxi '\n\n']);
                fprintf(fid,[str_rho '\n']);
                fprintf(fid,[str_drhodxi '\n\n']);
        end
        fprintf(fid,[str_w '\n']);
        fprintf(fid,[str_dwdxi '\n']);
        fprintf(fid,[str_distribution ';\n\n']);
        
        fprintf(fid,['M.u{s,e} = [']);
        for k = 1:length(M.u{s,e})
            fprintf(fid,num2str(M.u{s,e}(k)));
            if k < length(M.u{s,e})
                fprintf(fid,';');
            else
                fprintf(fid,'];\n');
            end
        end
        
        if options.replicates
            % consider replicates individually
            rs = 1:length(D(e).replicate);
        else
            % consider scaled and merged replicates
            rs = 1;
        end
        for r=rs
            fprintf(fid,['r=' num2str(r) ';\n']);
            fprintf(fid,[str_s{r} '\n']);
            fprintf(fid,[str_b{r} '\n']);
            fprintf(fid,[str_dsdxi{r} '\n']);
            fprintf(fid,[str_dbdxi{r} '\n']);
        end
    end
end

%% write parameter names in file
if options.write_parameters
    fprintf(fid, '\n\nparameters.name = {');
    str_max = 'parameters.max = [';
    str_min = 'parameters.min = [';
    str_constr_A = 'parameters.constraints.A = [';
    
    for k = 1:length(parameters.name)
        fprintf(fid,['''' regexprep(parameters.name{k},'\\','\\\\') '''']);
        str_max = strcat(str_max,num2str(parameters.max(k)));
        str_min = strcat(str_min,num2str(parameters.min(k)));
        if isfield(parameters,'constraints')
            str_constr_A = strcat(str_constr_A,num2str(parameters.constraints.A(k)));
        end
        
        if k < length(parameters.name)
            fprintf(fid,',...\n');
            str_max = [str_max ';'];
            str_min = [str_min ';'];
            str_constr_A = [str_constr_A ','];
        else
            fprintf(fid,'};\n');
            str_max = [str_max '];'];
            str_min = [str_min '];'];
            str_constr_A = [str_constr_A '];'];
        end
        
        
    end
    fprintf(fid, 'parameters.number = length(parameters.name);\n');
    fprintf(fid,[str_max '\n']);
    fprintf(fid,[str_min '\n']);
    if isfield(parameters,'constraints')
        fprintf(fid,[str_constr_A '\n']);
        str_constr_b = ['parameters.constraints.b = [' num2str(parameters.constraints.b) '];\n'];
        fprintf(fid,[str_constr_b '\n']);
    end
end
% Close file
fclose(fid);
% Rehash to ensure that function is known / used
rehash
disp('File generation done!')

% assing ouput
if nargout >= 1
    varargout{1} = M;
end
if nargout >= 2
    varargout{2} = conditions;
end
end


function retstr = replace_xi_x_u(symexpr)

retstr = '[';
for s1 = 1:size(symexpr,1)
    for s2 = 1:size(symexpr,2)
        retstr = strcat(retstr,regexprep(char(symexpr(s1,s2)),'xi_([0-9]+)','xi($1)'));
        retstr = regexprep(retstr,'u_([0-9]+)','u($1)');
        retstr = regexprep(retstr,'x_([0-9]+)','x($1)');
        if s2 < size(symexpr,2)
            retstr = [retstr ', '];
        end
    end
    if s1 < size(symexpr,1)
        if size(symexpr,2) > 1
            retstr = [retstr ';...\n\t'];
        else
            retstr = [retstr ';'];
        end
    end
end
retstr = [retstr ']'];

end

function str_dzdxi = getStrDerivative2Terms(sym_expr, x, dxdxi, xi)

str_dzdxi = 'bsxfun(@plus, [';

%% first term of the derivative
first_expr = jacobian(sym_expr,x)*dxdxi;
for k = 1:length(first_expr)
    str_temp = replace_by_bsxfun(char(first_expr(k)));
    str_temp = regexprep(str_temp,'u_([0-9]+)','u(:,$1)');
    str_temp = regexprep(str_temp,'x_([0-9]+)','x(:,$1)');
    str_dzdxi = strcat(str_dzdxi, regexprep(str_temp,'dxdxi_([0-9]+)','permute(dxdxi($1,:,:),[3,2,1])'));
    if k < length(first_expr)
        str_dzdxi = [str_dzdxi '; '];
    end
end
str_dzdxi = [str_dzdxi '],...\n\t '];
second_expr = jacobian(sym_expr,xi);
str_dzdxi = strcat(str_dzdxi,replace_xi_x_u(second_expr));
str_dzdxi = [str_dzdxi ')'];
end

function str_dzdxi = getStrDerivative3Terms(deriv_name, sym_expr, s, e,  x, dxdxi, sigma, dsigmadxi, xi)

str_dzdxi = ['M.' deriv_name '{s,e} = @(t,x,dxdxi,sigma,dsigmadxi,xi,u) bsxfun(@plus, ['];
%% first term of derivative
first_expr = jacobian(sym_expr{s,e},x)*dxdxi;
for k = 1:length(first_expr)
    %     if contains(char(first_expr(k)),'/')
    %         str_temp = regexprep(char(first_expr(k)),'([^/])+/([^/])+','bsxfun(@rdivide, $1, $2)');
    %         str_temp = regexprep(str_temp,'x_([0-9]+)','x(:,$1)');
    %     else
    %         str_temp = regexprep(char(first_expr(k)),'x_([0-9]+)','x(:,$1)');
    %     end
    str_temp = replace_by_bsxfun(char(first_expr(k)));
    %str_temp = replace_xi_x_u(str_temp);
    str_temp = regexprep(str_temp,'x_([0-9]+)','x(:,$1)');
    str_dzdxi = strcat(str_dzdxi, regexprep(str_temp,'dxdxi_([0-9]+)','permute(dxdxi($1,:,:),[3,2,1])'));
    if k < length(first_expr)
        str_dzdxi = [str_dzdxi '; '];
    end
end
str_dzdxi = [str_dzdxi '],...\n\t'];

%% second term of derivative
second_expr = jacobian(sym_expr{s,e},sigma)*dsigmadxi;
str_dzdxi = [str_dzdxi, 'bsxfun(@plus,['];
for k = 1:length(second_expr)
    %     if contains(char(second_expr(k)),'*')
    %         str_dzdxi= [str_dzdxi,regexprep(char(second_expr(k)),'([^/])+*([^/])+','bsxfun(@times, $1, $2)')];
    %     else
    %         str_dzdxi = strcat(str_dzdxi, char(second_expr(k)));
    %     end
    str_dzdxi = replace_by_bsxfun(char(second_expr(k)));
    if k < length(second_expr)
        str_dzdxi = [str_dzdxi '; '];
    end
end
str_dzdxi = [str_dzdxi '],...\n\t '];

%% third term
third_expr = jacobian(sym_expr{s,e},xi);

str_dzdxi = strcat(str_dzdxi,replace_xi_x_u(third_expr));
str_dzdxi = [str_dzdxi '));'];
end

function finalstring = replace_by_bsxfun(tmp)
% This function replaces in the provided equation the operations '*' and
% '/' by bsxfun.

% split the string in its subparts
count = 1;
strs{count}=tmp(1);
c=2;
while(c<=length(tmp))
    if ~(tmp(c)==' ')
        if tmp(c) == '('
            idx_next1 = find(ismember(tmp(c+1:end),')'),1,'first');
            idx_next2 = find(ismember(tmp(c+1:end),'*/('),1,'first');
            count = count+1;
            if isempty(idx_next2)||idx_next1 < idx_next2
                strs{count} = [tmp(c:c+idx_next1)];
                c = c+idx_next1;
            else
                strs{count} = tmp(c);
            end
        else
            if contains('()/*+-',tmp(c))
                count = count+1;
                strs{count}=tmp(c);
            else
                if contains('()/*+-',strs{count})
                    count = count+1;
                    strs{count} = [];
                end
                strs{count}=[strs{count},tmp(c)];
            end
        end
    end
    c=c+1;
end

idx_div = find(strcmp(strs,'/'));
idx_mult = find(strcmp(strs,'*'));
idx_leftbr = find(strcmp(strs,'('));
idx_rightbr = find(strcmp(strs,')'));

while not(isempty(idx_div) && isempty(idx_mult)) %loop until no / and * are in the string anymore
    for i = 1:length(idx_div)
        if not(ismember(idx_div(i)-1,idx_rightbr)||ismember(idx_div(i)+1,idx_leftbr))
            % can be merged
            strs{idx_div(i)-1} = ['bsxfun(@rdivide,' strs{idx_div(i)-1}];
            strs{idx_div(i)} = ',';
            strs{idx_div(i)+1} = [strs{idx_div(i)+1} ')'];
        end
    end
    for i = 1:length(idx_mult)
        if not(ismember(idx_mult(i)-1,idx_rightbr)||ismember(idx_mult(i)+1,idx_leftbr))
            % can be merged
            strs{idx_mult(i)-1} = ['bsxfun(@times,' strs{idx_mult(i)-1}];
            strs{idx_mult(i)} = ',';
            strs{idx_mult(i)+1} = [strs{idx_mult(i)+1} ')'];
        end
    end
    
    % current indices
    idx_leftbr = find(strcmp(strs,'('));
    idx_rightbr = find(strcmp(strs,')'));
    assert(numel(idx_leftbr) == numel(idx_rightbr))
    idx_div = find(strcmp(strs,'/'));
    idx_mult = find(strcmp(strs,'*'));
    
    % get bracket pairs
    if ~isempty(idx_rightbr)
        count = 1;
        for i = 1:length(idx_rightbr)
            tmp = idx_rightbr(i) - idx_leftbr;
            tmp(tmp<0) = nan;
            pair(count,:) = [idx_leftbr(tmp==min(tmp)),idx_rightbr(i)];
            count = count+1;
        end
        [~,idx_pair] = min(pair(:,2)-pair(1));
        
        % pair closest together
        pair = pair(idx_pair,:);
        flag = true;
        for j = 1:length(idx_div)
            if idx_div(j) > pair(1) && idx_div(j) < pair(2) % some * or / between the brackets
                flag = false;
            end
        end
        for j = 1:length(idx_mult)
            if idx_mult(j) > pair(1) && idx_mult(j) < pair(2) % some * or / between the brackets
                flag = false;
            end
        end
        if flag % can be merged
            count = 1;
            strstmp{1}=[];
            for j = 1:length(strs)
                if j >= pair(1) && j <= pair(2)
                    if length(strstmp) < count || isempty(strstmp{count})
                        strstmp{count} = strs{j};
                    else
                        strstmp{count} = [strstmp{count},strs{j}];
                    end
                    if j == pair(2)
                        count = count+1;
                    end
                else
                    strstmp{count} = strs{j};
                    count = count+1;
                end
            end
            strs = strstmp;
            clear strstmp
        end
    end
    % current indices
    idx_div = find(strcmp(strs,'/'));
    idx_mult = find(strcmp(strs,'*'));
    idx_leftbr = find(strcmp(strs,'('));
    idx_rightbr = find(strcmp(strs,')'));
end
finalstring = strcat(strs{1:end});
end

